<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ’œ 50 GrÃ¼nde warum ich dich liebe</title>
    <link rel="icon" href="https://fonts.gstatic.com/s/e/notoemoji/latest/2764_fe0f/512.png">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Georgia&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@3.3.0/tsparticles.bundle.min.js"></script>
    <style>
        /* ... (all your previous styles, unchanged) ... */
        /* Only modal-content-inner animation section changes: */
        .modal-content-inner { transition: none; will-change: transform, opacity;}
        .modal-content-inner.swipe-animate {
            transition: transform 0.44s cubic-bezier(.26,1.2,.46,1), opacity 0.26s cubic-bezier(.23,1,.32,1);
        }
        @media (max-width: 768px) {
            .modal-close {top: 0.3rem; right: 0.3rem; font-size: 2.7rem; padding: 1.2rem; z-index: 2001;}
            .modal-content {padding: 2.9rem 0.5rem 1.3rem 0.5rem; margin: 0.8rem;}
            .modal-counter {top: 0.15rem; left: 50%; transform: translateX(-50%); font-size: 0.90rem; padding: 0.38rem 1rem; z-index: 10;}
            .modal-number {font-size: 1.35rem; margin-bottom: 1.2rem; z-index: 5; position: relative;}
            .modal-text {font-size: 1.13rem;}
            .modal-nav { display: none; }
            .container { padding: 0.6rem; }
            .header { margin: 0.7rem; padding: 1.1rem 0.7rem;}
            .footer { padding: 1.1rem 0.7rem;}
        }
    </style>
</head>
<body>
<!-- ... (your html structure remains unchanged) ... -->
<script>
// ... (particles, content, and variable definitions unchanged) ...

// ----- Smooth Swipe and Slide Animation Logic -----
let startX = 0, lastX = 0, currentX = 0, isDragging = false, dragStartTime = 0;
let hasTouch = 'ontouchstart' in window;

function openModal(number) {
    currentModalIndex = availableReasons.indexOf(number);
    updateModalContent();
    modalOverlay.classList.add('active');
    document.body.style.overflow = 'hidden';
    modalOverlay.focus();
}
function updateModalContent() {
    const reasonNumber = availableReasons[currentModalIndex];
    const reasonText = reasons[reasonNumber];
    modalNumber.textContent = `#${reasonNumber}`;
    modalText.textContent = reasonText;
    modalCounter.textContent = `${currentModalIndex + 1} / ${availableReasons.length}`;
    modalPrev.disabled = currentModalIndex === 0;
    modalNext.disabled = currentModalIndex === availableReasons.length - 1;
    modalContentInner.style.transition = '';
    modalContentInner.style.transform = 'translate3d(0,0,0) scale(1)';
    modalContentInner.style.opacity = '1';
    modalContentInner.classList.remove('swipe-animate', 'swiping');
}

function animateCardGlideOut(direction, cb) {
    modalContentInner.classList.add('swipe-animate');
    modalContentInner.style.transform = `translate3d(${direction * window.innerWidth * 1.2}px,0,0) scale(0.96)`;
    modalContentInner.style.opacity = '0.2';
    modalContentInner.addEventListener('transitionend', function cleanup() {
        modalContentInner.removeEventListener('transitionend', cleanup);
        if (cb) cb(direction);
    }, { once: true });
}

function animateCardSlideIn(direction) {
    // Instantly move new card off-screen on opposite side
    modalContentInner.style.transition = 'none';
    modalContentInner.style.transform = `translate3d(${-direction * window.innerWidth * 1.2}px,0,0) scale(0.96)`;
    modalContentInner.style.opacity = '0.2';
    setTimeout(() => {
        modalContentInner.classList.add('swipe-animate');
        modalContentInner.style.transform = 'translate3d(0,0,0) scale(1)';
        modalContentInner.style.opacity = '1';
        modalContentInner.addEventListener('transitionend', function cleanup2() {
            modalContentInner.classList.remove('swipe-animate');
            modalContentInner.style.transition = '';
            modalContentInner.removeEventListener('transitionend', cleanup2);
        }, { once: true });
    }, 16); // allow paint
}

function handleSwipeEnd(direction) {
    animateCardGlideOut(direction, (dir) => {
        const newIndex = currentModalIndex + dir;
        if (newIndex >= 0 && newIndex < availableReasons.length) {
            currentModalIndex = newIndex;
            updateModalContent();
            animateCardSlideIn(dir);
        } else {
            smoothResetModalTransform();
        }
    });
}

function smoothResetModalTransform() {
    modalContentInner.classList.add('swipe-animate');
    modalContentInner.style.transform = 'translate3d(0,0,0) scale(1)';
    modalContentInner.style.opacity = '1';
    modalContentInner.addEventListener('transitionend', function cleanup() {
        modalContentInner.classList.remove('swipe-animate');
        modalContentInner.style.transition = '';
        modalContentInner.removeEventListener('transitionend', cleanup);
    });
}

// ----- Touch and Mouse Events -----
function handleTouchStart(e) {
    if (!hasTouch) return;
    startX = e.touches[0].clientX;
    lastX = startX;
    currentX = startX;
    dragStartTime = Date.now();
    isDragging = true;
    modalContentInner.classList.add('swiping');
    modalContentInner.classList.remove('swipe-animate');
    modalContentInner.style.transition = 'none';
}
function handleTouchMove(e) {
    if (!isDragging || !hasTouch) return;
    e.preventDefault();
    currentX = e.touches[0].clientX;
    let diffX = currentX - startX;
    modalContentInner.style.transition = 'none';
    modalContentInner.style.transform = `translate3d(${diffX}px,0,0) scale(0.98)`;
    modalContentInner.style.opacity = `${1 - Math.abs(diffX) / 350}`;
    lastX = currentX;
}
function handleTouchEnd(e) {
    if (!isDragging || !hasTouch) return;
    isDragging = false;
    let totalDiffX = currentX - startX;
    let timeDiff = Date.now() - dragStartTime;
    let velocity = totalDiffX / timeDiff;
    const minDistance = 60;
    const minVelocity = 0.5;
    if (
        Math.abs(totalDiffX) > minDistance ||
        Math.abs(velocity) > minVelocity
    ) {
        const direction = totalDiffX > 0 ? -1 : 1; // left is prev, right is next
        handleSwipeEnd(direction);
    } else {
        smoothResetModalTransform();
    }
    startX = 0;
    currentX = 0;
    dragStartTime = 0;
}
function handleMouseDown(e) {
    if (hasTouch) return;
    startX = e.clientX;
    lastX = startX;
    currentX = startX;
    dragStartTime = Date.now();
    isDragging = true;
    modalContentInner.classList.add('swiping');
    modalContentInner.classList.remove('swipe-animate');
    modalContentInner.style.transition = 'none';
    e.preventDefault();
}
function handleMouseMove(e) {
    if (!isDragging || hasTouch) return;
    currentX = e.clientX;
    let diffX = currentX - startX;
    modalContentInner.style.transition = 'none';
    modalContentInner.style.transform = `translate3d(${diffX}px,0,0) scale(0.98)`;
    modalContentInner.style.opacity = `${1 - Math.abs(diffX) / 350}`;
    lastX = currentX;
}
function handleMouseUp(e) {
    if (!isDragging || hasTouch) return;
    isDragging = false;
    let totalDiffX = currentX - startX;
    let timeDiff = Date.now() - dragStartTime;
    let velocity = totalDiffX / timeDiff;
    const minDistance = 60;
    const minVelocity = 0.5;
    if (
        Math.abs(totalDiffX) > minDistance ||
        Math.abs(velocity) > minVelocity
    ) {
        const direction = totalDiffX > 0 ? -1 : 1;
        handleSwipeEnd(direction);
    } else {
        smoothResetModalTransform();
    }
    startX = 0;
    currentX = 0;
    dragStartTime = 0;
}

// ----- Other unchanged event listeners and logic -----
modalClose.addEventListener('click', closeModal);
modalPrev.addEventListener('click', () => {
    handleSwipeEnd(-1);
});
modalNext.addEventListener('click', () => {
    handleSwipeEnd(1);
});
modalOverlay.addEventListener('click', (e) => {
    if (e.target === modalOverlay) {
        closeModal();
    }
});
modalContentInner.addEventListener('touchstart', handleTouchStart, { passive: false });
modalContentInner.addEventListener('touchmove', handleTouchMove, { passive: false });
modalContentInner.addEventListener('touchend', handleTouchEnd, { passive: false });
modalContentInner.addEventListener('mousedown', handleMouseDown);
document.addEventListener('mousemove', handleMouseMove);
document.addEventListener('mouseup', handleMouseUp);
document.addEventListener('keydown', (e) => {
    if (modalOverlay.classList.contains('active')) {
        switch(e.key) {
            case 'Escape': closeModal(); break;
            case 'ArrowLeft': if (currentModalIndex > 0) handleSwipeEnd(-1); break;
            case 'ArrowRight': if (currentModalIndex < availableReasons.length - 1) handleSwipeEnd(1); break;
        }
    }
});
document.getElementById('shuffleBtn').onclick = function() {
    availableReasons = [];
    let keys = Object.keys(reasons).sort(()=>Math.random()-0.5);
    reasons = {};
    keys.forEach((k,i) => reasons[i+1] = defaultReasons[k]);
    generateReasonsGrid();
};
generateReasonsGrid();

</script>
</body>
</html>
